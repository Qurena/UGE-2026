"""Здесь располагается теория по №25 (тип: МАСКИ): fnmatch; fullmatch"""

# ДОКУМЕНТАЦИЯ ПО ФУНКЦИИ fnmatch
"""
---------------------------------------------------------------------------
Функция fnmatch,  проверяющая полное соответствие строки 's' паттерну 'pattern'.
Возращает True, если строка соответсвует паттерну, и False - если нет
---------------------------------------------------------------------------

from fnmatch import fnmatch

if fnmatch(s, pattern):
    print(f"Строка {s} соответствует паттерну {pattern}")'''

---------------------------------------------------------------------------
Особенности записи паттернов для fnmatch:
?        один любой символ
*        последовательность любой длины, в том числе и нулевой
[abc]    один любой символ из набора 'abc'
---------------------------------------------------------------------------
"""

# ДОКУМЕНТАЦИЯ ПО ФУНКЦИИ re.fullmatch
"""
---------------------------------------------------------------------------
Функция re.fullmatch,  проверяющая полное соответствие строки 's' паттерну 'pattern'. 
Возвращает объект типа Match, если совпадение найдено, либо None - если совпадения нет
---------------------------------------------------------------------------

import re

if re.fullmatch(pattern, s):
    print(f"Строка {s} соответствует паттерну {pattern}")

---------------------------------------------------------------------------
Особенности записи паттернов регулярных выражений:
s?      строка из одного символа s или пустая строка
s+      символ s встречается подряд один или более раз
s*      символ s встречается подряд ноль или более раз
s{n}    символ s встречается подряд ровно n раз 
s{n,m}  символ s встречается подряд от n до m раз 
s{,m}   символ s встречается подряд от 0 до m раз 
s{n,}   символ s встречается подряд n и более раз 

s+  === s{1, }
s?  === s{0, 1}
s*  === s{0, }

  .         один любой символ
[abc]       один любой символ из набора 'abc'
[^abc]      один любой символ не из набора 'abc'
[0-9]       один символ из множества цифр от 0 до 9
[^0-9]      один символ не из множества цифр от 0 до 9
[a-z]       один символ из множества букв от a до z

.*          любая последовательность символов

[abc]       один любой символ из набора 'abc'
[abc]?      пустая строка или один символ из набора
[abc]+      подстрока длиной 1+ состоящая из символов указанного набора
[abc]*      подстрока длиной 0+ состоящая из символов указанного набора
[a-z0-9]    последовательность любой комбинации букв лат. алфавита и всех цифр

(abc|def)   одна из двух подстрок
(abc)       строка abc
(abc)?      пустая строка или строка abc
(abc)+      подстрока состоящая из 1+ повторения строки abc
(abc)*      подстрока состоящая из 0+ повторений строки abc

(abc){n}    строка abc встречается подряд ровно n раз

Примечаниe:
Для использования в регулярном выражении символа, также являющегося оператором, 
необходимо его экранировать, то есть записать перед ним знак обратного слэша.
Например, для использовании точки как символа, а не оператора любого символа,
нужно написать "\."

В начале строки стоит строка / символ после - используем "^"
В конце строки стоит строка / символ после - используем "$"
Буква Ё не входит в строку русских букв: [А-ЯЁ] [а-яё]
---------------------------------------------------------------------------
"""

# ДОКУМЕНТАЦИЯ ПО ФУНКЦИИ re.finditer() ИСПОЛЬЗУЕМ ТОЛЬКО ТОГДА, КОГДА ПЕРВЫЙ СИМВОЛ НЕ СОДЕРЖИТСЯ В ПОДХОДЯЩЕЙ ПОСЛЕДОВАТЕЛЬНОСТИ -> ОНИ НЕ МОГУТ ПЕРЕСЕКАТЬСЯ
'''
---------------------------------------------------------------------------
Синтаксис:
for match in re.finditer(pattern, text):
    max_len = max(max_len, match.end() - match.start())

Функция выводит текст в формате match object:
    <re.Match object; span=(354849, 355079), match='8131555BSG11995KS5S991F155S3E37S5735939T77113513X>
    
Главное свойство этой функции:
    ОНА ВСЧИТАЕТ ТОЛЬКО НЕПЕРЕСЕКАЮЩИЕСЯ ПОДХОДЯЩИЕ СТРОКИ.
    то есть, если мы ищем строку, начинающуюся с символа E и заканчивающуюся на него, при этом содержащая его внутри, функция выведет лишь первую 
---------------------------------------------------------------------------
'''

'''
Написать регулярные выражения:

1. Для произвольного чётного положительного числа.

([1-9][0-9]*[24680]|[2468])

2. Для строку, состоящую из 4 букв латинского алфавита в начале и 3 цифр в конце.

^[a-z]{4}.*[0-9]{3}$

3. Для произвольного слова русского языка.

([А-ЯЁ])?[а-яё]+-?[а-яё]+

4. Для всех падежных форм слова "книга" единственного и множественного числа.

(книг[аиеу]?|книг(ой|ах|ою|ами|ам))
книг([иеу]|о(й|ю)|а(ми|м|х)?)?

5. Для  email адреса вида "user_name@domain.smth".

[a-z]+_[a-z]+@[a-z]+\.[a-z]*+

6. Для арифметического выражения, содержащего знаки '+-' и целые неотрицательные числа.

([1-9][0-9]*|0)[+-]([1-9][0-9]*|0)

7. Для бесконечно длинного арифметического выражения, содержащего знаки '+-' и целые неотрицательные числа.

(([1-9][0-9]*|0)[+-])+([1-9][0-9]*|0)

8. Строка, начинающаяся с четной цифры, в которой ровно 76 букв E и одна чётная цифра:
pattern = r'[02468]([^E13579]*E){76}[^E13579]*'

'''

# ПРИМЕРЫ:
'''
1.1. Паттерн "1Ч3*4?5" регулярным выражением можно записать так:
pattern = "1[02468]3[0-9]*4[0-9]5"

1.2 Паттерн "1Ч3*4?5" в записи для fnmatch:
pattern = "1[02468]3*4?5"

2.1. Паттерн регулярного выражения для нечётного числа большего 10:
pattern = "[1-9][0-9]*[13579]"

2.2. Паттерн проверки нечётности числа для fnmatch:
pattern = "*[13579]"

'''
