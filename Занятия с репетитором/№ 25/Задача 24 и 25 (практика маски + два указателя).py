"""Здесь расположены задачи № 25 на тему МАСКИ из классной и домашней работы"""

# ЗАДАЧА 1
'''
from fnmatch import fnmatch


for num in range(0, 10**9, 7977):
    if fnmatch(str(num), "?1*23*29"):
        print(num, num // 7977, sep='\t')

# если выводим в порядке убывания: range((10*9 // 7977) * 7977, 0, -7977)
'''

# ЗАДАЧА 2
'''
https://education.yandex.ru/ege/task/ebe58680-2764-40a5-9014-f8b94f5828a8
---------------------------------------------------------------------------
Назовём маской числа последовательность цифр,
в которой также могут встречаться следующие символы:

символ «?» означает ровно одну произвольную цифру;
символ «*» означает любую последовательность цифр произвольной длины.
В том числе «*» может задавать и пустую последовательность;
символ «Ч» означает ровно одну четную цифру.

Найдите все натуральные числа, делящиеся нацело на 780 и 1323 не превышающие 3*10⁸,
код которых соответствует маске «*Ч32??».

В ответе запишите найденные числа в десятичной системе счисления в порядке убывания,
а справа от каждого числа — соответствующее частное от деления на 780.
---------------------------------------------------------------------------

import re

a = []
for i in range((3*(10**8) // 780) * 780, -1, -780): # идем вниз от ближайшего числа к 3*(10**8), кратного 780
    if re.fullmatch("[0-9]*[02468]32[0-9][0-9]", str(i)) and i % 1323 == 0:  # МАСКА: *Ч32??
         print(i, i // 780, sep='\t')
'''

# ЗАДАЧА 3
'''
from fnmatch import fnmatch

def find_divs(N: int) -> list[int]:
    divs = []
    for div in range(1, int(N ** 0.5) + 1):
        if N % div == 0:
            divs.append(div)
            divs.append(N // div)
    return sorted(divs)


def so(n: int) -> bool:
    f = False
    p = find_divs(n)
    if len(p) == 24:
        f = True
        for k in range(24):
            if not fnmatch(str(p[k]), "4*"):
                f = False
    return f


for i in range(10 ** 6):
    if so(i):
        print(i, max(find_divs(i)))
'''

# ЗАДАЧА 4
'''
https://education.yandex.ru/ege/task/9b0225e7-e7ad-4808-9f08-36e400596508
---------------------------------------------------------------------------
Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:

символ «?» означает ровно одну произвольную цифру;
символ «*» означает любую последовательность цифр произвольной длины.
В том числе «*» может задавать и пустую последовательность.
Например, маске 123*4?5 соответствуют числа 123405 и 12300405.

Среди натуральных чисел, не превышающих 10⁷, найдите все числа, удовлетворяющие маске 34?8*9 , 
имеющие более 4 простых делителей (не равных самому числу и 1). 

В ответ в порядке возрастания выпишите подходящие числа и их наибольшие простые делители.
---------------------------------------------------------------------------

import re

def is_prime(n: int) -> bool:
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True

def find_primes(n: int) -> list:
    divs = []
    for i in range(2, n):
        if n % i == 0 and is_prime(i):
            divs.append(i)
    return divs if divs else [0]

for k in range(10**7 + 1):
    if re.fullmatch("34[0-9]8[0-9]*9", str(k)):
        if len(find_primes(k)) > 4:
            print(k, max(find_primes(k)), sep='\t')
'''

# ЗАДАЧА 5
'''
https://education.yandex.ru/ege/task/83afed62-b003-45be-b7f8-a004109ff15a
---------------------------------------------------------------------------
Назовём маской числа последовательность цифр, в которой также могут встречаться следующие символы:

символ «?» означает ровно одну произвольную нечётную цифру;
символ «*» означает любое чётное число; в том числе «*» может задавать и пустую последовательность.
Например, маске 123*4?5 соответствуют числа 123738465 и 123475.

Среди натуральных чисел, не превышающих 10¹⁰, найдите 5 наибольших чисел,
соответствующих маске ?136*1, делящихся на 11071 без остатка.

В ответе запишите в первом столбце таблицы найденные числа в порядке возрастания,
а во втором столбце — соответствующие им результаты деления этих чисел на 11071.
---------------------------------------------------------------------------

import re

c = 0
a = []
for i in range((10 ** 10 // 11071) * 11071, 0, -11071):
    if c != 5 and re.fullmatch("[13579]136[1-9][0-9]*[2468]1", str(i)):
        a.append(i)
        c += 1
    if c == 5:
        break

for k in range(len(a) - 1, -1, -1):
    print(a[k], a[k] // 11071, sep='\t')

'''

'''
import re

def so(i: int) -> list[int]:
    re_divs = []
    for k in range(1, int(i**0.5) + 1):
        if re.fullmatch("4[0-9]*", str(k)):
            if i % k == 0:
                re_divs.append(k)
                if re.fullmatch("4[0-9]*", str(i//k)):
                    re_divs.append(i//k)
    if re.fullmatch("4[0-9]*", str(i)):
        re_divs.append(i)

    return re_divs

for m in range(10**6):
    if len(so(m)) == 24:
        print(m, max(so(m)))
        break
'''



'''
https://education.yandex.ru/ege/task/60136ef5-552a-4bc0-9224-2914e321d93b
Текстовый файл состоит из цифр 0, 6, 7, 8, 9 и знаков арифметических операций «–» и «*» (вычитание и умножение).
Определите максимальное количество символов в непрерывной последовательности, которая является корректным
арифметическим выражением с целыми неотрицательными числами. В этом выражении никакие два знака арифметических
операций не стоят рядом, в записи чисел отсутствуют незначащие (ведущие) нули и число 0 не имеет знака.

import re

pattern = r"(([6789][06789]*|0)[-*])+([6789][06789]*|0)"

with open("24.txt") as file:
  text = file.readline()

ml = 0
for match in re.finditer(pattern, text):
  ml = max(ml, match.end() - match.start())

print(ml)

'''

'''
Найдите максимальное значение подходящей строки из файла 24.txt

import re

pattern = r"(([6789][06789]*|0)[-*])+([6789][06789]*|0)"

with open("24.txt") as file:
  text = file.readline()

ml = 0
for match in re.finditer(pattern, text):
  ml = max(ml, eval(match.group()))

print(ml)
'''

# ЗАДАЧА 6
'''
https://education.yandex.ru/ege/task/9b0225e7-e7ad-4808-9f08-36e400596508
---------------------------------------------------------------------------

from fnmatch import fnmatch


def find_prime(n: int) -> bool:
    for i in range(2, int(n ** 0.5) + 1):
        if n % i == 0:
            return False
    return True


def ldivs(n: int) -> int:
    divs = []

    for i in range(2, n // 2 + 1):
        if n % i == 0 and find_prime(i):
            divs.append(i)

    return divs


for i in range(1, 10 ** 7):
    if fnmatch(str(i), "34?8*9") and len(ldivs(i)) > 4:
        print(i, max(ldivs(i)), sep='\t')
        
'''

# ЗАДАЧА 7 (ВАЖНАЯ ДЕТАЛЬ С ПОРЯДКОМ В РЕГУЛЯРКЕ)
'''
https://education.yandex.ru/ege/task/98ae80c8-1e05-4cad-b4cc-4adc1edcc487
---------------------------------------------------------------------------
Текстовый файл состоит из символов P, Q, R и S. В прилагаемом файле определите
максимальное количество символов в непрерывной подпоследовательности, которая
состоит из идущих подряд групп символов SQRP. При этом в начале и в конце искомой
последовательности группа символов SQRP может быть неполной.

Искомая последовательность должна содержать не менее одной полной группы символов SQRP.
Например, условию задачи удовлетворяют RPSQRPSQRPS, или PSQRPSQRPSQ, или SQRPSQRPSQR и т. п.
---------------------------------------------------------------------------

import re

pattern = r"(QRP|RP|P)?(SQRP)+(SQR|SQ|R)?" #если мы напишем (S|SQ|SQR), и он наткнётся на S, которая подходит, то SQ и SQR уже рассматриваться не будут.
ml = 0

with open("24.txt") as file:
  text = file.readline()

for match in re.finditer(pattern, text):
  ml = max(ml, match.end() - match.start())
print(ml)
'''

# ЗАДАЧА 8 (3 решения: не через регулярки, через регулярки, через регулярки и срезы)
'''
https://education.yandex.ru/ege/task/bcd7eb8e-445f-413b-a844-6e8394d50eb7
---------------------------------------------------------------------------
Текстовый файл состоит из символов Y, A, N, D, E и X.

Определите максимальную длину последовательности символов в прилагаемом файле, для которой выполняются условия:

1. последовательность состоит из символов N и D (не считая первого и последнего символа);
2. последовательность начинается и заканчивается символом E.
---------------------------------------------------------------------------
РЕШЕНИЕ НЕ ЧЕРЕЗ РЕГУЛЯРКИ

with open("24.txt") as file:
    text = file.readline()

pos_e = []

for i, letter in enumerate(text):  # возвращает кортежи, первый - символ, второй - индекс
    if letter == "E":
        pos_e.append(i)

# text = text.replace('N', 'D') # чтобы было проще 

max_len = 0
for i in range(len(pos_e) - 1):
    correct = True
    for letter in text[pos_e[i] + 1:pos_e[i + 1]]:
        if letter not in 'ND':
            correct = False
            break
    if correct:
        max_len = max(max_len, pos_e[i + 1] - pos_e[i] + 1)

print(max_len)

---------------------------------------------------------------------------
РЕШЕНИЕ ЧЕРЕЗ РЕГУЛЯРКИ

import re

max_len = 0 
with open("24.txt") as file:
    text = file.readline()
    
for match in re.finditer("E[ND]+", text):
  if text[match.end()] == 'E':
    max_len = max(max_len, match.end() - match.start() + 1)
print(max_len)

---------------------------------------------------------------------------
РЕШЕНИЕ СРЕЗАМИ С фУНКЦИЕЙ re.search(pattern, text)

import re

with open("24.txt") as file:
  text = file.readline() 

max_len = 0
start = 0
res = re.search("E[ND]+E", text[start:])
while res != None:
  max_len = max(max_len, res.end() - res.start())
  start += res.start() + 1
  res = re.search("E[ND]+E", text[start:])

print(max_len)

'''


# ЗАДАЧА 9
'''
https://education.yandex.ru/ege/task/a24ce8b0-6d3c-4963-af6e-dfbc118b2d1c
---------------------------------------------------------------------------
Текстовый файл состоит из десятичных цифр и заглавных букв латинского алфавита.
Определите в прилагаемом файле последовательность из максимального количества
идущих подряд символов, среди которых ровно 35 букв S, начинающуюся чётной цифрой,
не содержащую других чётных цифр, кроме первой.

В ответе запишите число — количество символов в найденной последовательности.
---------------------------------------------------------------------------

import re

pattern = r"[02468]([^S02468]*S){35}[^S02468]*"

with open("24.txt") as file:
  text = file.readline()

max_len = 0
for match in re.finditer(pattern, text):
  max_len = max(max_len, match.end() - match.start())

print(max_len)
'''

# ЗАДАЧА 9 (РЕШЕНИЕ НЕ РЕГУЛЯРКАМИ) - способ скользящего окна, способ двух указателей
'''
https://education.yandex.ru/ege/inf/task/dc2aa40a-ee08-4e9c-b43f-81fbccbd1d7e
---------------------------------------------------------------------------
Текстовый файл состоит из символов латинского алфавита.
Определите максимальную длину непрерывной подпоследовательности,
состоящей только из уникальных символов.
---------------------------------------------------------------------------

with open("24.txt") as file:
    text = file.readline()

lset = set()
max_len = 0

# ASDFARTYU
start = end = 0
while end < len(text):
    if text[end] not in lset:
        lset.add(text[end])
        end += 1 # двигаем индекс вправо (в данном случае end = 4)
    else:
        lset.remove(text[start])
        max_len = max(max_len, end - start)
        start += 1

max_len = max(max_len, end - start)

print(max_len)
'''

# ЗАДАЧА 9 способ двух указателей
'''
https://education.yandex.ru/ege/inf/task/b0ac476e-824a-4d0c-8b3f-5c52f208a0ef
---------------------------------------------------------------------------
Текстовый файл состоит из символов TUVWXYZ. Определите в прилагаемом файле
максимальное количество идущих подряд символов
(длину непрерывной подпоследовательности), среди которых символ T встречается
ровно 100 раз, а символ U - ровно 50 раз.
---------------------------------------------------------------------------
# Доступен файл для чтения: 24.txt

with open("24.txt") as file:
    text = file.readline()

start = end = 0

max_len = ct = cu = 0

while end < len(text):
    if ct <= 100 and cu <= 50:
        ct += (text[end] == "T")
        cu += (text[end] == "U")
        end += 1
        if ct == 100 and cu == 50:
            max_len = max(max_len, end - start)

    else:
        ct -= (text[start] == "T")
        cu -= (text[start] == "U")
        start += 1

print(max_len)

# 821
'''

# 10
'''
---------------------------------------------------------------------------
Текстовый файл состоит не более чем из 1 046 730 букв латинского алфавита.
Определите максимальное количество идущих подряд символов,
среди которых нет подстроки AHAHA.
---------------------------------------------------------------------------

# Доступен файл для чтения: 24.txt
import re

f = open("24.txt")
text = f.readline()

pattern = r"AHA(HA)+"

mx = start = 0

for match in re.finditer(pattern, text):
    end = match.start()
    mx = max(mx, end - start + 4 + 4)
    start = match.end()

mx = max(mx, len(text) - start + 4)
print(mx)
# 2371
'''