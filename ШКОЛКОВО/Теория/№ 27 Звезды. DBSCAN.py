"""Теория по номеру 27 по звездам и кластерам через алгоритм DBSCAN по вебу https://3.shkolkovo.online/lesson/36565"""

'''
Если в задаче кластеры странной формы (если точки трудно раскидать, то решаем через DBSCAN)

Как работает DBSCAN:
Мы берем рандомную звезду и ищем ближайшие к ней, дальше еще ближайшие к ней и так далее.
Через несколько итераций у нас образуются кластеры. 

Этапы решения:
Визуализация через Libra
1. Открываем файл в блокноте -> Ctrl+A
2. Вставляем в либру с разделителем ТАБУЛЯЦИЯ (можно через данные -> текст по столбцам)
3. Выделяем эти 2 столбца
4. Строим по ним диаграмму: вставка -> диаграмма (ТИП: XY)
5. Мы можем поменять интервалы: формат оси -> выставляем параметры
6. Пишем код.
'''

from math import dist

f = open("27_file")
a = [list(map(float, i.replace(",", ".").split())) for i in f if "X" not in i]
clusters = []
cl_total = []
r = 0.5  # это может быть прописано в задании - минимальное расстояние между звездами
# Если в задании нет радиуса, мы с помощью черепахи определяем, есть ли у нас мусор
# потом печатаем len(clusters). Если мусора нет и длина больше кол-ва основных кластеров, то
# мы должны увеличить радиус.

# На простом примере с 1 звездой: Сначала мы берем звезду и отбираем все звезды, находящиеся на расстоянии от
# выбранной звезды не большим r. Когда такие звезды заканчиваются, мы убираем выбранные звезды из a
# clusters.append([a.pop(0)])
# for i in a:
#     if dist(clusters[0][0], i) < r:
#         clusters[0][0].append(i)
#         a.remove(i)

while a:
    clusters.append([a.pop(0)])  # мы добавили звезду в виде списка в кластер и тут же удалили её из a
    for i in clusters[-1]:  # для звезды в последнем добавленном кластере
        for j in a[:]:
            # Если мы пишем a[:] вместо a, то при повторном вызове a, мы не вызываем новую a.
            # Из-за того, что мы уменьшили a на одну звезду, у нас в дальнейшем может произойти проскок.
            # Каждый раз, когда а уменьшается, мы берем i из нового a, из-за этого и происходит проскок.

            # Почему будет происходить проскок?
            # 0 1 2 3 удаляем 1 после того, как мы добавили цифру в лист
            # 0 2 3 получаем список
            # при его вызове программа думает, что второй элемент был просмотрен ранее, хотя это новый элемент,
            # идущий после просмотренного, а срез a[:] - копия списка
            if dist(i, j) <= r:
                clusters[-1].append(j)
                # x, y = i
                # goto(x*m, y*m)
                # dot(5, 'blue') - визуализация построения кластера 0, если перенесем импорт черепахи вверх
                a.remove(j)  # если мы добавили звезду в clusters, то удаляем её из a

# Убираем НЕ кластеры
for i in clusters:
    if len(i) > 10:
        cl_total.append(i)

px = py = 0
# Найдем центроиды кластеров
for i in clusters:
    if len(i) > 5: # если в кластере больше 5 звезд
        mn = 10**10
        for star in i:
            s = 0
            for j in i:
                s += dist(star, j)
            if s < mn:
                mn = s
                center = star
        px += center[0]
        py += center[1]
print(int((px/4)*100), int((py/4)*100))

# Построим кластер
from turtle import *
tracer(0)
m = 25
for j in clusters:
    for i in clusters[j]:
        x, y = i
        goto(x*m, y*m)
        dot(5, 'blue')

done()
