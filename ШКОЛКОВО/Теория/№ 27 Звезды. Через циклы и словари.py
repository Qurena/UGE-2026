"""Теория по номеру 27 по звездам и кластерам"""
'''
Этапы решения:
Визуализация через Libra
1. Открываем файл в блокноте -> Ctrl+A
2. Вставляем в либру с разделителем ТАБУЛЯЦИЯ (можно через данные -> текст по столбцам)
3. Выделяем эти 2 столбца
4. Строим по ним диаграмму: вставка -> диаграмма (ТИП: XY)
5. Мы можем поменять интервалы: формат оси -> выставляем параметры
PyCharm
6. Открываем Pycharm и пишем код
7. Раскидываем звезды по кластерам
8. Используем черепаху, визуализируя расположение кластеров
9. Строим функцию, график которой не проходит через кластеры (лин. прямая / окружность - зависит от задачи)
10. В черепашке пишем цикл, с помощью которого мы отобразим полуплоскость, 
образованную с помощью найденной прямой
11. Находим количества звезд в кластерах (импортируем dist из модуля math - функция модуля math в Python,
которая вычисляет евклидово расстояние между двумя точками в n-мерном пространстве)
12. Ищет центры кластеров через цикл
13. Визуализируем центры через черепашку и проверяем на адекватность
14. Комментируем черепашку (Ctrl+/)
15. Вычисляем значения из условия (для ответа)
'''
from math import dist

f = open('27.txt')
a = [list(map(float, i.replace(",", '.').split())) for i in f if 'X' not in i]
clusters = [[],[],[]]

for i in a:
    x, y = i
    if x > 4:
        clusters[2].append(i)
    elif y < (-3)*(x/7) + 3: # смотрим пункт 9: можем заменить на ур-е окр-ти - (x - 1.3)**2 + (y - 0.3)**2 < 1.5**2
        clusters[0].append(i)
    else:
        clusters[1].append(i)

centers = []
for n in range(3):
    mn = 10*10
    for star in clusters[n]:
        s = 0
        for k in clusters[n]:
            s += dist(star, k)
        if s < mn:
            mn = s
            mn_star = star
    centers.append(mn_star)
px = (centers[0][0] + centers[1][0] + centers[2][0]) / 3
py = (centers[0][1] + centers[1][1] + centers[2][1]) / 3
print(int(px*10_000), int(py*10_000))


from turtle import *

m = 50
tracer(0)
up()
cl = ['red', 'green', 'blue']

for j in range(3):
    for i in clusters[j]:
        x, y = i
        goto(x*m, y*m)
        dot(5, cl[j])

for i in range(-100, 100):
    for j in range(-100, 100):
        x, y = i/10, j/10 # задаем плотность наших точек
        if y < (-3)*(x/7) + 3: # можем заменить на ур-е окр-ти - (x - 1.3)**2 + (y - 0.3)**2 < 1.5**2
            goto(x*m, y*m)
            dot(3, 'purple')

for i in centers:
    x, y = i
    goto(x*m, y*m)
    dot(15)

done()

