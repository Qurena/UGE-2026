"""Теория по номеру 24: метод двух указателей"""


'''
---------------------------------------------------------------------------
(0) В ЦИКЛЕ WHILE НЕ МОЖЕТ БЫТЬ УСЛОВИЯ, ПРИ КОТОРОМ CB < N. (ЗАДАЧА # 5)
Как решать такие номера, если более строгого условия, где CX > K, нет?
Мы засовываем расчет конечного значения (длины подстроки) прямо в цикл:
    while cy >= 100: # Определите длину минимальной подстроки, содержащей не менее 100 символов Y.
        mn = min(mn, end - start + 1)
        if s[start] == 'Y':
            cy -= 1
        start += 1

---------------------------------------------------------------------------

(1) ОДИН СИМВОЛ В ПОДСТРОКЕ ВСТРЕЧАЕТСЯ N РАЗ
Сначала имеем два указателя в начале строки.
Дальше мы запускаем указатель через цикл и считаем количество букв "B".
Когда в получившейся строке количество букв "B" стало превосходить предел,
мы начинаем двигать указатель start до тех пор,
пока не уберем лишнюю "B" слева. При этом мы каждую итерацию цикла
заносим длину подстроки, при которой буква встречается N раз.

---------------------------------------------------------------------------

(2) ОДИН СИМВОЛ В ПОДСТРОКЕ ВСТРЕЧАЕТСЯ N РАЗ И ВТОРОЙ СИМВОЛ/ПОДСТРОКА ВСТРЕЧАЕТСЯ НЕ МЕНЕЕ/НЕ БОЛЕЕ K РАЗ
Если подстрока, делаем замену на * (while '2025' in s: s = s.replace('2025','*')) 
Если есть два и более условий (буква А больше 70 раз, а буква В ровно 50 и тд),
то мы определяем более строгое условие и уже по нему строим цикл while.
В КОНЦЕ НЕ ЗАБЫВЕМ ПРИБАВИТЬ К ДЛИНЕ ПОДСТРОКИ ОСТАВШУЮСЯ ЧАСТЬ ЗАМЕНЕННОЙ
ЧАСТИ: mx = max(mx, end - start + 1 + c2*3)

---------------------------------------------------------------------------

(3) СИМВОЛЫ/ПОДСТРОКИ ВСТРЕЧАЮТСЯ НЕ МЕНЕЕ/НЕ БОЛЕЕ K, N, ... РАЗ (много нестрогих условий)
Если у нас несколько равных по силе условий, делаем цикл while через or:
while cg > 2 or cd > 1 or c3 > 5:

---------------------------------------------------------------------------

(4.1) ДОПУСТИМ, КАЖДАЯ ИЗ БУКВ UVWXYZ ВСТРЕЧАЕТСЯ НЕ БОЛЕЕ 100 РАЗ
Если у нас слишком много равных по силе условий, делаем цикл while через max():
while max(u, v, w, x, y, z) > 100:

---------------------------------------------------------------------------

(4.2) Если буквы идут в алфавитном порядке, используем решение через ord():
c = [0] * 6 # тк UVWXYZ - 6 букв
start = mx = 0
for end in range(len(s)):
    if s[end] in 'UVWXYZ':
        c[ord(s[end]) - 85] += 1
---------------------------------------------------------------------------
'''


# 1
'''
Текстовый файл состоит из символов A,B, C,D,E, F.
Определите в прилагаемом файле максимальное количество
идущих подряд символов (длину непрерывной подпоследовательности),
среди которых символ B встречается ровно 53 раза.


f = open("24.txt")
s = f.readline()

start = cb = mx = 0

for end in range(len(s)):
    if s[end] == 'B':
        cb += 1
    while cb > 53:
        if s[start] == 'B':
            cb -= 1
        start += 1
    if cb == 53:    
        mx = max(mx, end - start + 1)

print(mx)
'''

# 2
'''
Текстовый файл состоит из десятичных цифр и заглавных букв
латинского алфавита. Определите в прилагаемом файле максимальное
количество идущих подряд символов, среди которых подстрока 2025
встречается не менее 90 раз и при этом содержится ровно 80 букв Y.
В ответе запишите число – количество символов в найденной последовательности.


f = open("24.txt")
s = f.readline()

while '2025' in s:
    s = s.replace('2025', '*')

c2 = cy = mx = start = 0
for end in range(len(s)):
    if s[end] == '*':
        c2 += 1
    if s[end] == 'Y':
        cy += 1
    while cy > 80:
        if s[start] == '*':
            c2 -= 1
        if s[start] == 'Y':
            cy -= 1
        start += 1
    if cy == 80 and c2 >= 90:
        mx = max(mx, end - start + 1 + c2*3)

print(mx)
'''

# 3
'''
Текстовый файл содержит только заглавные буквы латинского алфавита (ABC...Z).
Определите максимальное количество идущих подряд символов, среди которых
каждая из букв C и D встречается не более двух раз.

f = open("24.txt")
s = f.readline()
cd = cc = max = start = 0

for end in range(len(s)):
    if s[end] == 'C':
        cc += 1
    if s[end] == 'D':
        cd += 1
    while cc > 2 or cd > 2:
        if s[start] == 'C':
            cc -= 1
        if s[start] == 'D':
            cd -= 1
        start += 1
    if cc <= 2 and cd <= 2:
        mx = max(mx, end - start + 1)

print(mx)
'''

# 4.1 (РЕШЕНИЕ В ЛОБ)
'''
Текстовый файл содержит только заглавные буквы латинского алфавита (ABC...Z).
Определите максимальное количество идущих подряд символов,
среди которых каждая из букв UVWXYZ встречается не более ста раз.

f = open("24.txt")
s = f.readline()

u = v = w = x = y = z = start = mx = 0

for end in range(len(s)):
    if s[end] == 'U':
        u += 1
    if s[end] == 'V':
        v += 1
    if s[end] == 'W':
        w += 1
    if s[end] == 'X':
        x += 1
    if s[end] == 'Y':
        y += 1
    if s[end] == 'Z':
        z += 1

    while max(u, v, w, x, y, z) > 100:
        if s[start] == 'U':
            u -= 1
        if s[start] == 'V':
            v -= 1
        if s[start] == 'W':
            w -= 1
        if s[start] == 'X':
            x -= 1
        if s[start] == 'Y':
            y -= 1
        if s[start] == 'Z':
            z -= 1

        start += 1

    if max(u, v, w, x, y, z) <= 100:
        mx = max(mx, end - start + 1)
print(mx)
'''

# 4.2 (РЕШЕНИЕ ЧЕРЕЗ ord)
'''
f = open("24.txt")
s = f.readline()
c = [0] * 6 # тк UVWXYZ - 6 букв

start = mx = 0
for end in range(len(s)):
    if s[end] in 'UVWXYZ':
        c[ord(s[end]) - 85] += 1
# ord('U') = 85, а эти буквы идут последовательно в строке
# теперь c - список, где индекс обозначает букву, а
# значение - сколько раз она встречается в подстроке (s[start:end+1])
    while max(c) > 100:
        if s[start] in 'UVWXYZ':
            c[ord(s[end]) - 85] -= 1
    if max(c) <= 100:
        mx = max(mx, end - start + 1)

print(mx)
'''


# 5
'''
Текстовый файл состоит не более чем из 10**6 символов латинского алфавита.
Определите длину минимальной подстроки, содержащей не менее 100 символов Y.

f = open("24.txt")
s = f.readline()

mn = 10**10

start = cy = 0

for end in range(len(s)):
    if s[end] == 'Y':
        cy += 1
    while cy >= 100:
        mn = min(mn, end - start + 1)
        if s[start] == 'Y':
            cy -= 1
        start += 1

print(mn)
'''