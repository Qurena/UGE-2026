"""Теория по номеру 24: регулярные выражения """

'''
Регулярные выражения - инструмент, с помощью которого мы можем искать 
соответствие строк / символов в строке

s = r'...' - чистой воды строка, в которой, допустим, \n будут считаться обычными символами
s = '...' - строка, в которой, допустим, \n будет считаться командой

s = rf'...{d}...{h}...' - строка, позволяющая склеивать строки и втыкать \... как символ
это нужно для того, чтобы визуально сокращать регулярки:
p = r'0|[1-9][0-9]*'
np = rf'{p}([+-]{p})+'

Использование регулярок:
[а-я] - одна любая маленькая буква от а до я
[а-я]{1-6} - подстрока, состоящая из символов от а до я, длины от 1 до 6
[а-я]* - длина от 0 до бесконечности 
[а-я]? - либо одна любая маленькая буква от а до я, либо пустота
[а-я]+ - от 1 до бесконечности

Примеры использования регулярок:
[0-9]+[+-] - строка любой положительной длины и один знак + или - в конце
([0-9]+[+-])+ - строка выше, но повторенная от 1 раза
[1-9][0-9]* - любое положительное число 
0|[1-9][0-9]* - 0 или строка выше 
[1-9][0-9]*[24680] - любое четное число
[1-9][0-9]*[13579] - любое нечетное число 


Основные функции:
1. for i in finditer(pattern, s) 
Функция ищет в строке s символы / подстроки, подходящие к pattern.
Выводит максимально возможные варианты (в строке -+*-123**5 по паттерну [1-9]* мы
получим числа 123 и 5)

2. res = i.group()
функция преобразует объект i в формат строки (всегда используется в выводе значений в цикле finditer(p, s)

3. eval(s)
выполняет код, заключенный в строке s 
eval('5+6+10') = 21

4. lookahead ( (?=(регулярка) ) - допустим, нам нужно найти макс длину строки, в которой ровно 50 сочетаний символов CD. 
Методом finditer это сделать не получится, потому что он не учитывает ПЕРЕСЕЧЕНИЕ (тк эта строка может оканчиваться на C, а дальше D).
Именно поэтому мы:
- начальная регулярка [A-E]*(CxD[A-E]*){50}
- берем регулярку в (), группируем ее -> ( [A-E]*(CxD[A-E]*){50} )
- впереди приписываем ?= -> ?=([A-E]*(CxD[A-E]*){50})
- снова все группируем -> ( ?=([A-E]*(CxD[A-E]*){50}) )
- в цикле finditer добавляем в аргумент i.group() единичку -> i.group(1)

Пример кода:
from re import * 
f = open('24.txt')
s = f.readline()
s = s.replace('CD', 'CxD')

pattern = '(?=([A-E]*(CxD[A-E]*){50}))'

mx = 0
for i in finditer(pattern, s):
    t = i.group(1)
    mx = max(mx, len(t))
    
print(mx - 50)  # вычитаем 50, так как у нас вместо CD в строке CxD
'''