# Введение в классы:

'''https://metanit.com/python/tutorial/7.1.php'''

'''
Python имеет множество встроенных типов, например, int, str и так далее, которые мы можем использовать в программе.
Но также Python позволяет определять собственные типы с помощью классов.
Класс представляет некоторую сущность. Конкретным воплощением класса является объект.

Можно еще провести следующую аналогию. У нас у всех есть некоторое представление о человеке, у которого есть имя, возраст, какие-то другие характеристики.
Человек может выполнять некоторые действия - ходить, бегать, думать и т.д. То есть это представление, которое включает набор характеристик и действий, можно назвать классом.
Конкретное воплощение этого шаблона может отличаться, например, одни люди имеют одно имя, другие - другое имя. И реально существующий человек будет представлять объект этого класса.
В языке Python класс определяется с помощью ключевого слова class:
'''

class #название_класса:
    #атрибуты_класса
    #методы_класса


class Person:
    pass


tom = Person()  # определение объекта tom
bob = Person()  # определение объекта bob
'''В данном случае вызов Person() представляет вызов конструктора'''



# Конструкторы:
'''
Итак, для создания объекта класса используется конструктор.
Так, выше когда мы создавали объекты класса Person, мы использовали конструктор по умолчанию,
который не принимает параметров и который неявно имеют все классы.
Однако мы можем явным образом определить в классах конструктор с помощью специального метода,
который называется __init__() (по два прочерка с каждой стороны).
К примеру, изменим класс Person, добавив в него конструктор:
'''
class Person:
    # конструктор
    def __init__(self):
        print("Создание объекта Person")


tom = Person()  # Создание объекта Person


# Атрибуты объекта:
'''
self - позволяет обращаться к своим полям внутри класса. 
Использовать self и init необходимо при работе с ООП.
При создании класса объявляете конструктор из полей, которые вы хотите инициализировать вместе с созданием экземпляра этого класса.

Ну и вот, встретил на просторах интернета:
dark: у котов внутри есть мурчалка

dark: она реализована для всех котов в классе кот

dark: в объекте кот надо как то вызвать метод мурчало у класса кот

dark: как ты это сделаешь?

dark: кот.мурчало()

dark: ежели ты вызовешь кот.мурчало(), муркнут сразу все коты на свете

dark: а ежели ты вызовешь self.мурчало(), муркнет только тот кот, на которого указывает self
'''
class Person:

    def __init__(self, name, age):
        self.name = name  # имя человека | атрибут класса
        self.age = age  # возраст человека | атрибут класса

# Атрибуту self.name присваивается значение переменной name.
# Атрибут age получает значение параметра age.
# Название атрибутов не обязательно должно соответствовать названиям параметров.

tom = Person("Tom", 22)

# обращение к атрибутам
# получение значений
print(tom.name)  # Tom
print(tom.age)  # 22
# изменение значения
tom.age = 37
print(tom.age)  # 37



# Методы классов:
'''
Методы класса фактически представляют функции, которые определенны внутри класса и которые
определяют его поведение.
Например, определим класс Person с одним методом:
'''
class Person:  # определение класса Person
    def say_hello(self):
        print("Hello")


tom = Person()
tom.say_hello()  # Hello

'''
Здесь определен метод say_hello(), который условно выполняет приветствие - выводит строку на консоль.
При определении методов любого класса, как и конструктора, первый параметр метода представляет ссылку
на текущий объект, который согласно условностям называется self.
Через эту ссылку внутри класса мы можем обратиться к функциональности текущего объекта.
Но при самом вызове метода этот параметр не учитывается.
'''

'''
Если метод должен принимать другие параметры, то они определяются после параметра self,
и при вызове подобного метода для них необходимо передать значения:
'''
class Person:  # определение класса Person
    def say(self, message):  # метод
        print(message)


tom = Person()
tom.say("Hello METANIT.COM")  # Hello METANIT.COM

'''
Здесь определен метод say(). Он принимает два параметра: self и message.
И для второго параметра - message при вызове метода необходимо передать значение.
'''


class Person:

    def __init__(self, name, age):
        self.name = name  # имя человека
        self.age = age  # возраст человека

    def display_info(self):
        print(f"Name: {self.name}  Age: {self.age}")


tom = Person("Tom", 22)
tom.display_info()  # Name: Tom  Age: 22

bob = Person("Bob", 43)
bob.display_info()  # Name: Bob  Age: 43

'''
Здесь определяется метод display_info(), который выводит информацию на консоль.
И для обращения в методе к атрибутам объекта применяется слово self: self.name и self.age
'''



# Деструкторы:
'''
Кроме конструкторов классы в Python также могут определять специальные
методы - деструкторы, которые вызываются при удалении объекта.

Деструктор представляет собой метод __del__(self), в который,
как и в конструктор, передается ссылка на текущий объект.
В деструкторе определяются действия, которые надо выполнить при удалении объекта,
например, освобождение или удаление каких-то ресурсов, которые использовал объект.

Деструктор вызывается автоматически интерпретатором, нам не нужно его явным образом вызывать.
'''


class Person:

    def __init__(self, name):
        self.name = name
        print("Создан человек с именем", self.name)

    def __del__(self):
        print("Удален человек с именем", self.name)


tom = Person("Tom")

'''
Здесь в деструкторе просто выведится уведомление об удалении объекта Person.
Программа создает один объект Person и хранит ссылку на него в переменной tom.
Создание объекта вызовет выполнение конструктора. При завершении программы автоматически будет выполняться деструктор объекта tom.
В итоге консольный вывод программы будет следующим:
Создан человек с именем Tom
Удален человек с именем Tom
'''